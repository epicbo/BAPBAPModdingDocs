{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the BAPBAP modding docs","text":"<p>TODO</p>"},{"location":"getting-started/overview/","title":"Overview","text":"<p>TODO</p>"},{"location":"guides/augments/","title":"Augments","text":""},{"location":"guides/augments/#overview","title":"Overview","text":"<p>BAPBAP uses a class called BAPBAP.Entities.Passive to apply a passive modifier to an entity. Every augment is a passive and inherits from this class, but not every passive is an augment. We also have a class called BAPBAP.Entities.PassiveSO (a passive scriptable object) which hold the configuration for every passive. Whenever a passive is applied to an entity (for example when a player select an augment), the PassiveSO object is used to create the Passive instance that is then applied to the entity. In other words, there are only ever one instance of PassiveSO for each type of passive, but there can be multiple instances of Passive at once. Of course, Passive and PassiveSO are just base classes, the actual effect of the passives are implemented in child classes of these two. </p> <p>Every passive has a unique id (passiveId). Often we only have the passiveId to work with and need to retrieve the underlying PassiveSO object. Luckily there is the BAPBAP.Local.PassiveManager class which is often quite accessible, that in turn has a BAPBAP.Entities.PassiveLibrary object (library) that finally has an array called passives that acts as a master list for every passive in the game. For example, if we want to add a new augment to the game, we would have add them to this array (more on this later).</p> <p>Another class that is good to know about is BAPBAP.Entities.CharPassives. It is attached to a specific character and handles things such as adding, removing and triggering effects of passives on that character. Very useful if we want to make our own augments. Finally, there's also BAPBAP.Local.AugmentManager which handles information that is specific to augments, such as, which augments are character specific, which require previous augments (eg. you can't get Firewave Cooldown before having Firewave) and so on. Also very important if we want to add more augments.</p>"},{"location":"guides/augments/#hidden-augments","title":"Hidden augments","text":"<p>The game comes with a bunch of augments that exist in the code but are not enabled in game. Luckily it's fairly easy to enable them. Since they're already in the game, only the host needs the mod, which is a nice bonus. Worth noting is that the polish of them vary greatly. Some are are fully functional and can be added without issue, some work but may not have the best icon/description/visuals/balance and some are completely broken. Try them out and see which ones you like!</p> <p>Step one is figuring out the passiveId of the augments we are interested in using. In this example, we will use ID 247, called \"Critical Ability\" which lets us critically hit with abilities and adds a small amount of crit chance. </p> <p>Next step is patching AugmentManager.PreAwake. I found this method useful for this purpose because it is only called once, and at that point all augments have already been initialized, but we can still make changes to them. It is important to understand how augments are selected ingame. There are multiple \"augment pools\" that the game selects from. Starter, Character, Wildcard and Fallback. When you get an option to select an augment, they are picked as such:</p> <ul> <li>One augment is picked from Starter</li> <li>One augment is picked from Wildcard</li> <li>One augment is either from Starter or Character (50% for each)</li> </ul> <p>If there is no possible augment to pick for a specific augment slot, then one is picked from the Fallback pool (you may have seen some of the really weak ones that give 7% attack speed and such). This can happen if there are no augments available left in that pool to pick. With this information in mind, we have the following fields in AugmentManger:</p> <ul> <li>allAugmentIds: A list of passiveId of all available augments. Actually, I am not sure where this is being used or whether we actually need to modify it, doesn't hurt to.</li> <li>charAugmentIds: A 2D array where the first index refers to the charId of the character, the second to the passiveId. This one is used when creating a game and setting which augments should be available. Adding an augment to this array means that it will show up in that menu under the that specific character. It is also used to build the list of character specific augments in the Training mode.</li> <li>genericAugmentIds: Similar to charAugmentIds, but for the non-character specific augments.</li> <li>selectionFallbackAugments: Here we have a list of augments in the Fallback pool. Note that these are PassiveSO and not IDs.</li> <li>startingAugmentTrees: The augments in the Starter pool, as AugmentManager.AugmentTree objects. The augment field is the augment itself (again as PassiveSO and not and ID). There are also some additional fields that can be useful, such as requiredCharacter if you only want specific characters to be able to obtain it, incompatibleAugments and also childrenAugments, which will become available when the player obtains the augment (think Firewave Cooldown after obtaining Firewave).</li> <li>wildCardAugmentTree: Very similar to startingAugmentTree, but for the Wildcard pool instead.</li> <li>wildCardRareAugmentTree: Not 100% sure what the deal is with this one, but I guess it was used in another game mode. The game seems to pick a Wildcard augment from either of them (if it can't find a valid augment in one of the wildcard trees, it will just select the other). Might as well add wildcard augments to this one just to be sure.</li> </ul> <p>Here's what the code could look like (I went with adding the augment to the Starter pool).</p> <pre><code>[HarmonyPatch(typeof(PassiveManager), nameof(PassiveManager.PreAwake))]\npublic class HiddenAugmentPatch\n{\n    public static void Postfix(AugmentManager _instance)\n    {\n        var passiveId = 247;\n\n        // Get a reference to the PassiveManager. All managers are available from LocalManager.Instance!\n        var passiveManager = LocalManager.Instance.passiveManager;\n\n        // Fetch the PassiveSO from the PassiveManager\n        var newAugment = passiveManager.library.passives[passiveId];\n\n        // We need a new AugmentTree object, but we'll be lazy and just clone an existing one\n        var newAugmentTree = _instance.startingAugmentTrees[0].MemberwiseClone().Cast&lt;AugmentManager.AugmentTree&gt;();\n\n        // Let's clear its children by replacing the value with an empty array. \n        newAugmentTree.childrenAugments = new Il2CppReferenceArray&lt;AugmentManager.DependencyAugment&gt;(0);\n\n        // Set the augment in the augment tree to our new augment\n        newAugmentTree.augment = newAugment;\n\n        // Add the passiveId of our agument to allAugmentIds and genericAugmentIds. \n        // Note: since these fields are arrays (of type Il2CppStructArray&lt;int&gt;), you'll have to create a new one of 'length + 1',\n        // copy the values from the old one, add the new passiveId, and then override the old one. \n        // I am using a helper I wrote for this.\n        _instance.allAugmentIds = Util.AppendIntArray(_instance.allAugmentIds, passiveId);\n        _instance.genericAugmentIds = Util.AppendIntArray(_instance.genericAugmentIds, passiveId);\n\n        // Similar to above, but here we're adding our new augment tree to the starting augment tree pool.\n        _instance.startingAugmentTrees = Util.AppendReferenceArray(_instance.startingAugmentTrees, newAugmentTree);\n    }\n}\n</code></pre>"},{"location":"guides/augments/#modifying-existing-augments","title":"Modifying existing augments","text":"<p>TODO</p>"},{"location":"guides/augments/#custom-augments","title":"Custom augments","text":"<p>TODO</p>"}]}